---
title: "React Query: From Confusion to Confidence"
seoTitle: "Mastering React Query: Boost Your Confidence"
seoDescription: "Learn to manage server data in React apps using React Query, transforming confusion into confidence with a practical, experience-based guide"
datePublished: Mon Jan 05 2026 13:18:43 GMT+0000 (Coordinated Universal Time)
cuid: cmk16scaq000c02l96191f1qx
slug: react-query-from-confusion-to-confidence
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/64YrPKiguAE/upload/30dd652341e98e812582fdba590de429.jpeg
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1767619041138/701bc793-963e-4d8f-b916-1efa2580cd66.jpeg
tags: software-development, web-development, full-stack, reactjs, redux, software-engineering, frontend-development, full-stack-development

---

## An Experience-Based Practical Guide

---

## Why I'm Writing This (Real Talk)

I still remember the first time I encountered React Query in a project. Our codebase was, like, literally a complete mess. I'm talking `useState`, `useEffect`, and just... random API calls everywhere. No organization. No pattern. Here's what we were dealing with:

* Data getting fetched in like 10 different places (I actually counted once)
    
* Stale data that caused bugs only showing up in production, naturally
    
* Loading states that made no sense in relation to what was actually happening
    
* Race conditions that only showed up on specific days or after certain user interactions (so fun to debug)
    
* Cache invalidation, which was just... I'd spend 30 minutes wondering why something wasn't refreshing
    

One day this coworker just goes "dude, just use React Query." And I'm like, cool, I'll look at the docs. My brain literally melted. Like, the concepts, the API, everything felt overwhelming.

But I had to learn it because, honestly, the codebase was becoming impossible to work with. And then once it clicked? Everything just... clicked. Like a switch.

This guide exists because I suffered through figuring this out myself, and I don't want you to waste time on the same stuff I wasted time on. I'm just writing this like we're talking â€“ like, colleague to colleague grabbing coffee or whatever. Not trying to sound smart or impress anyone.

---

## Table of Contents

1. [The Problem React Query Solves](#the-problem-react-query-solves)
    
2. [Installation & First Steps](#installation--first-steps)
    
3. [Understanding useQuery](#understanding-usequery)
    
4. [Real Data Fetching Examples](#real-data-fetching-examples)
    
5. [Mutations - Creating/Updating Data](#mutations---creatingupdating-data)
    
6. [Cache Management (The Secret Sauce)](#cache-management-the-secret-sauce)
    
7. [Advanced Patterns](#advanced-patterns)
    
8. [Testing React Query](#testing-react-query)
    
9. [Common Mistakes I Made](#common-mistakes-i-made)
    
10. [Interview Questions](#interview-questions)
    
11. [Performance Tips](#performance-tips)
    

---

## The Problem React Query Solves

### Let's Look at What We're Doing Wrong

Here's the code I used to write all the time before React Query:

```typescript
// The way I wrote code for 3+ years (ðŸ˜…)
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(`/api/users/${userId}`)
      .then(r => r.json())
      .then(data => {
        setUser(data);
        setError(null);
      })
      .catch(err => setError(err))
      .finally(() => setLoading(false));
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{user?.name}</div>;
}
```

That's 17 lines of boilerplate just to fetch some user data. And I'd repeat this pattern in every single component. Let me tell you what was broken about this approach:

* **Copy-paste hell**: I'd copy this pattern everywhere. Want to fetch users? Here's the pattern. Need posts? Here's the same pattern again. One bug fix needed in 10 places.
    
* **Stale data problems**: User switches tabs, clicks around. The data is now 5 minutes old. But the component has no idea. No automatic refresh.
    
* **Manual caching**: If two components needed the same data, I'd fetch it twice. No sharing. No deduplication.
    
* **State management chaos**: Managing three separate states (`loading`, `error`, `data`) manually led to bugs. What if loading is true AND there's data? What state is that?
    
* **Race conditions**: User fast-clicks between profiles. Requests come back out of order. Profile A data loads, then Profile B request finishes first. User sees wrong data.
    
* **Memory leaks**: Component unmounts while fetch is in-flight? Boom. "Can't perform setState on unmounted component" warnings everywhere.
    
* **No retry logic**: Network glitch? Too bad. Manual retry handling would make code even messier.
    
* **Cleanup nightmare**: Each component needs cleanup logic. It's easy to forget.
    

### What React Query Actually Does

Compare that to this:

```typescript
// With React Query - that's it
function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then(r => r.json())
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{user?.name}</div>;
}
```

Three lines (well, technically it's still a hook, but conceptually three lines). And you get:

* âœ… Automatic caching (fetch once, use everywhere)
    
* âœ… Deduplication (same request = one network call)
    
* âœ… Built-in retry logic with exponential backoff
    
* âœ… Smart stale data handling
    
* âœ… Automatic refetching when data gets old
    
* âœ… Loading and error states managed for you
    
* âœ… No memory leaks
    
* âœ… DevTools that show you exactly what's happening
    

Honestly? This is not hyperbole. React Query saved me hours of debugging time.

---

## Installation & First Steps

### Setup (Takes 5 Minutes)

```bash
npm install @tanstack/react-query
```

Then wrap your app with QueryClientProvider:

```typescript
// main.tsx or index.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
  <QueryClientProvider client={queryClient}>
    <App />
  </QueryClientProvider>
);
```

### DevTools (Optional but Highly Recommended)

```bash
npm install @tanstack/react-query-devtools
```

```typescript
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

<QueryClientProvider client={queryClient}>
  <App />
  <ReactQueryDevtools initialIsOpen={false} />
</QueryClientProvider>
```

This gives you a browser extension that shows all your queries, their states, and cache status. It's like X-ray vision for your data.

---

## Understanding useQuery

### The Basic Pattern

```typescript
const { data, isLoading, error, isError } = useQuery({
  queryKey: ['users', userId],
  queryFn: async () => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  }
});
```

Simple enough, right? But there's actually some really important stuff hiding in here. Let me break it down because I spent like two weeks getting this wrong initially.

### Breaking This Down

#### 1\. QueryKey - The Most Important Part (Seriously)

```typescript
// This is basically the "ID" for your cached data
queryKey: ['users', userId]

// Same queryKey = same cache entry
// Change userId = React Query knows it's a different query and refetches
```

Okay so here's the thing I didn't get at first â€“ queryKey isn't just for naming. It's like... it's how React Query actually knows what's going on. Dependencies are just built into your queryKey somehow.

**The rule I learned the hard way**: If you're using something in your `queryFn`, it has to be in your `queryKey`. Change the queryKey, React Query refetches. Simple concept, but I totally messed this up.

```typescript
// âœ… GOOD
useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId)
})

// âŒ BAD - I did this and wasted so much time
useQuery({
  queryKey: ['user'],  // userId missing
  queryFn: () => fetchUser(userId)  // userId changes but no refetch
})
```

Yeah, I made this mistake constantly when I was learning. Junior devs do too.

#### 2\. QueryFn - Where You Actually Fetch Data

This is just an async function that returns your data. Whatever works for you:

```typescript
queryFn: () => fetch('/api/users').then(r => r.json())
queryFn: async () => await axios.get('/api/users')
queryFn: () => api.getUsers()  // Your own API wrapper
```

Not complicated. But there's one thing I keep forgetting to mention: **throw errors, don't hide them**.

```typescript
// âŒ WRONG - This traps errors silently
queryFn: async () => {
  const res = await fetch('/api/users');
  return res.json();  // If status is 500, you still try to parse as JSON
  // React Query thinks everything is fine!
}

// âœ… RIGHT - Check the response
queryFn: async () => {
  const res = await fetch('/api/users');
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}
```

I learned this the hard way when users were seeing blank screens and the error state was undefined. The fetch was "succeeding" (request went through) but the response was a 500 error page. React Query had no idea.

#### 3\. Return Values - What You Get Back

```typescript
const {
  data,              // undefined, then your data
  isLoading,         // true while fetching first time
  isPending,         // true while any fetch is happening
  isError,           // true if fetch failed
  error,             // Error object if failed
  status,            // 'pending' | 'error' | 'success'
  isFetching,        // true if background refetch happening
  isRefetching,      // true if refetch (not initial load)
  refetch,           // Manual function to refetch
} = useQuery({...});
```

---

## Real Data Fetching Examples

### Example 1: Simple GET Request

```typescript
// Fetching a list of posts
function PostsList() {
  const { data: posts, isLoading } = useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const res = await fetch('https://api.example.com/posts');
      return res.json();
    }
  });

  if (isLoading) return <div>Loading posts...</div>;

  return (
    <ul>
      {posts?.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

**What's happening behind the scenes:**

1. Component mounts, query fires
    
2. Request goes to API
    
3. While waiting: `isLoading = true`, component shows "Loading posts..."
    
4. Data arrives: `data = posts`, `isLoading = false`
    
5. User navigates away and comes back 2 minutes later
    
6. Cache still valid (default 5-minute stale time)
    
7. Posts list appears instantly from cache
    
8. Meanwhile React Query quietly refetches in the background
    
9. New data arrives, updates if anything changed
    
10. User never saw a loading spinner
    

This automatic background refetching is my favorite feature. User's experience is seamless but data stays fresh.

### Example 2: GET with Parameters

```typescript
function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: async () => {
      const res = await fetch(`/api/users/${userId}`);
      if (!res.ok) throw new Error('User not found');
      return res.json();
    }
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <h1>{user?.name}</h1>;
}
```

So in a real app: user's on John's profile, clicks to Jane's. `userId` changes, queryKey changes, React Query sees the new key and fetches Jane's data. Then they go back to John? Still in cache, loads instantly. It's honestly the best part of React Query.

### Example 3: Pagination

```typescript
function PostsList() {
  const [page, setPage] = useState(1);
  const { data, isLoading } = useQuery({
    queryKey: ['posts', page],
    queryFn: async () => {
      const res = await fetch(`/api/posts?page=${page}`);
      return res.json();
    }
  });

  return (
    <div>
      {data?.posts.map(post => <div key={post.id}>{post.title}</div>)}
      <button onClick={() => setPage(p => p + 1)}>Next</button>
    </div>
  );
}
```

Each page gets its own cache entry. Go back and forth? No refetching. Pretty straightforward.

### Example 4: Search/Filter

```typescript
function SearchUsers() {
  const [searchTerm, setSearchTerm] = useState('');

  const { data: results } = useQuery({
    queryKey: ['users', 'search', searchTerm],
    queryFn: async () => {
      const res = await fetch(`/api/users?search=${searchTerm}`);
      return res.json();
    },
    enabled: searchTerm.length > 2
  });

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {results?.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

The `enabled` option prevents fetching when the search term's too short. No need to hit the API for single letters.

### Example 5: Dependent Queries

```typescript
function UserPosts() {
  const { data: user } = useQuery({
    queryKey: ['currentUser'],
    queryFn: () => fetch('/api/me').then(r => r.json())
  });

  const { data: posts } = useQuery({
    queryKey: ['user', user?.id, 'posts'],
    queryFn: () => fetch(`/api/users/${user.id}/posts`).then(r => r.json()),
    enabled: !!user?.id
  });

  if (!user) return <div>Loading user...</div>;
  if (!posts) return <div>Loading posts...</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      {posts.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}
```

Fetch the user first, then when you have the user ID, fetch their posts. The `enabled` flag basically says "don't run this until I'm ready."

---

## Mutations - Creating/Updating Data

### The Difference Between Queries and Mutations (And Why It Matters)

Queries are for reading. Mutations are for writing. I know that sounds obvious, but understanding this distinction changed everything for me.

With queries, React Query just handles it all â€“ caching, refetching, when things get stale. Pretty automatic.

With mutations, you're basically saying "I'm about to change something on the server." And you need to tell React Query what happens after â€“ like "refetch the list" or "just update the cache directly" or whatever.

### Simple Mutation

```typescript
function CreatePost() {
  const { mutate, isPending, error } = useMutation({
    mutationFn: async (newPost: { title: string; content: string }) => {
      const res = await fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newPost)
      });
      if (!res.ok) throw new Error('Failed to create post');
      return res.json();
    },
    onSuccess: () => {
      alert('Post created!');
    },
    onError: (error) => {
      alert(`Error: ${error.message}`);
    }
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    mutate({
      title: formData.get('title') as string,
      content: formData.get('content') as string
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" placeholder="Title" required />
      <textarea name="content" placeholder="Content" required />
      <button disabled={isPending}>
        {isPending ? 'Creating...' : 'Create Post'}
      </button>
    </form>
  );
}
```

`mutate` is what you call to trigger the mutation. It's not async â€“ it fires off the request. If you need to wait for it (like to redirect after success), use `mutateAsync` instead:

```typescript
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  try {
    await mutateAsync(newPost);
    // Redirect or whatever
    navigate('/posts');
  } catch (error) {
    // Handle error
  }
};
```

### The Real Power: Cache Invalidation After Mutations

Here's where mutations get interesting. After creating a post, you probably want the posts list to update. You could:

**Option 1: Invalidate the cache** (Simple & Safe)

```typescript
const queryClient = useQueryClient();

const { mutate } = useMutation({
  mutationFn: async (newPost) => {
    const res = await fetch('/api/posts', {
      method: 'POST',
      body: JSON.stringify(newPost)
    });
    return res.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['posts'] });
  }
});
```

So the flow is: user submits, mutation runs, creates the post, `onSuccess` fires, cache gets invalidated, React Query refetches, new post appears. It's pretty smooth.

**Option 2: Optimistic Updates** (Advanced but feels Amazing)

This is where you update the UI immediately, before the server confirms:

```typescript
const { mutate } = useMutation({
  mutationFn: (newPost) => fetch('/api/posts', {
    method: 'POST',
    body: JSON.stringify(newPost)
  }).then(r => r.json()),

  onMutate: async (newPost) => {
    // Pause any pending refetches
    await queryClient.cancelQueries({ queryKey: ['posts'] });

    // Get the old data in case we need to rollback
    const previousPosts = queryClient.getQueryData(['posts']);

    // Immediately update the cache with new post (optimistic)
    queryClient.setQueryData(['posts'], (old: any[]) => [
      ...old,
      { ...newPost, id: Date.now() }  // Temporary ID
    ]);

    // Return the old data so we can rollback if needed
    return { previousPosts };
  },

  onError: (err, newPost, context) => {
    // If mutation fails, rollback to old data
    if (context?.previousPosts) {
      queryClient.setQueryData(['posts'], context.previousPosts);
    }
  },

  onSuccess: () => {
    // Refetch to get real ID and data from server
    queryClient.invalidateQueries({ queryKey: ['posts'] });
  }
});
```

Honestly I was skeptical about this at first. But when you see it in action? User submits form, post appears instantly, network syncs in the background. If it fails? Rolls back automatically. It's pretty cool.

I've used it on projects and yeah, apps definitely feel faster. Especially on slow networks.

---

## Cache Management (The Secret Sauce)

### Stale vs Fresh (And Why You Need to Understand This)

This is the concept that finally made React Query "click" for me. For the longest time I thought "stale" and "fresh" were basically the same thing. They're not. They're completely different and understanding the difference is key.

**Fresh data** = You trust it, use it  
**Stale data** = You don't trust it, but use it while we get new data in the background

```typescript
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  staleTime: 1000 * 60 * 5,  // 5 minutes - stays "fresh"
  gcTime: 1000 * 60 * 10,    // 10 minutes - keeps in memory after becoming stale
});
```

**staleTime**: How long you trust this data before it gets marked stale.

* `0`: Trust it for 0 seconds (basically immediately stale, but still reuse cache if available)
    
* `1000 * 60 * 5`: Trust it for 5 minutes
    

**gcTime**: How long to keep data in memory after it's stale. After this? It's deleted. Why keep stale data at all? Because users navigate back quickly and it's faster to show cached data than nothing.

### Real-World Example: Different Data, Different Strategies

```typescript
// User settings - changes rarely, user opens menu sometimes
// Don't need fresh data constantly
useQuery({
  queryKey: ['settings'],
  queryFn: fetchSettings,
  staleTime: 1000 * 60 * 60,  // 1 hour
  gcTime: 1000 * 60 * 60 * 24  // 24 hours (keep it long)
})

// Real-time notifications - always need latest
// Check frequently
useQuery({
  queryKey: ['notifications'],
  queryFn: fetchNotifications,
  staleTime: 0,  // Always stale
  refetchInterval: 1000 * 10,  // Check every 10 seconds
  refetchIntervalInBackground: true  // Even if browser tab is hidden
})

// Comments on a post - somewhat real-time, but not critical
useQuery({
  queryKey: ['post', postId, 'comments'],
  queryFn: () => fetchComments(postId),
  staleTime: 1000 * 60,  // 1 minute - fairly fresh
  refetchOnWindowFocus: true  // Refetch when user comes back to tab
})
```

### Manual Invalidation (When Automatic Isn't Enough)

Sometimes you know the cache is out of date and you need to refetch NOW:

```typescript
const queryClient = useQueryClient();

// Invalidate a specific query
queryClient.invalidateQueries({ queryKey: ['posts', 1] });

// Invalidate all post-related queries
queryClient.invalidateQueries({ queryKey: ['posts'] });

// Invalidate with a filter function
queryClient.invalidateQueries({
  predicate: (query) => {
    return query.queryKey[0] === 'posts' && query.queryKey[1] > 5;
  }
});

// Invalidate everything at once (nuclear option, use rarely)
queryClient.invalidateQueries();
```

I use this when the user performs an action that I KNOW affects the cache. Like "delete post" â†’ I know the posts list is out of date. Don't wait for staleTime, invalidate immediately.

### Manually Setting Data (Pre-loading)

```typescript
// Prefetch - load before user needs it
// Great for pagination, infinite scroll, or hover
await queryClient.prefetchQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId)
});

// Or just set data directly (when you get it from another source)
queryClient.setQueryData(['user', 1], { id: 1, name: 'John', email: 'john@example.com' });
```

I use prefetching a lot for pagination. When user hovers the "Next" button, silently load the next page. They click? It's instant.

---

## Advanced Patterns

### Pattern 1: Suspense (React 18+)

```typescript
// Enable suspense
const { data: user } = useQuery({
  queryKey: ['user', id],
  queryFn: fetchUser,
  suspense: true  // Component will suspend while loading
});

// Component can't render without data, so wrap with Suspense
<Suspense fallback={<div>Loading...</div>}>
  <UserProfile userId={id} />
</Suspense>
```

### Pattern 2: Infinite Queries (Pagination)

```typescript
function InfinitePostsList() {
  const {
    data,
    hasNextPage,
    fetchNextPage,
    isFetchingNextPage
  } = useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: ({ pageParam }) => 
      fetch(`/api/posts?page=${pageParam}`).then(r => r.json()),
    initialPageParam: 1,
    getNextPageParam: (lastPage) => lastPage.nextPage
  });

  return (
    <div>
      {data?.pages.map((page) =>
        page.posts.map(post => (
          <div key={post.id}>{post.title}</div>
        ))
      )}
      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage ? 'Loading...' : 'Load more'}
      </button>
    </div>
  );
}
```

### Pattern 3: Polling (Checking Periodically)

```typescript
// Check for new notifications every 5 seconds
useQuery({
  queryKey: ['notifications'],
  queryFn: fetchNotifications,
  refetchInterval: 5000,  // 5 seconds
  refetchIntervalInBackground: true  // Even if tab inactive
});
```

### Pattern 4: Request Deduplication

This is automatic, but here's how it works:

```typescript
// Component A
useQuery({ queryKey: ['user', 1], queryFn: fetchUser });

// Component B (same screen)
useQuery({ queryKey: ['user', 1], queryFn: fetchUser });

// Network request = 1 (not 2!)
// Both components share the same cache entry
```

---

## Testing React Query

### The Key Insight About Testing

Here's what I learned: testing React Query apps is way easier than testing old-school useEffect code. Why? Because you can control the cache directly. No more "wait for setTimeout, hope the fetch completes, maybe the component unmounted..."

With React Query, you're testing logic, not async timing. It's glorious.

### Setup for Testing

```typescript
// test-setup.ts
import { QueryClient } from '@tanstack/react-query';

export const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,  // Don't retry in tests (way slower)
        staleTime: Infinity  // Keep data fresh in tests
      }
    }
  });
```

Key settings:

* `retry: false` - Don't retry failed requests 3 times in tests. That's slow.
    
* `staleTime: Infinity` - In tests you don't care about staleness, just functionality
    

### Testing a Query

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import { QueryClientProvider } from '@tanstack/react-query';
import { createTestQueryClient } from './test-setup';

test('should fetch and display user', async () => {
  const queryClient = createTestQueryClient();
  
  // Mock the fetch
  global.fetch = jest.fn(() =>
    Promise.resolve({
      json: () => Promise.resolve({ id: 1, name: 'John' })
    })
  );

  render(
    <QueryClientProvider client={queryClient}>
      <UserProfile userId="1" />
    </QueryClientProvider>
  );

  // Wait for data to load
  await waitFor(() => {
    expect(screen.getByText('John')).toBeInTheDocument();
  });

  expect(global.fetch).toHaveBeenCalledWith('/api/users/1');
});
```

### Testing Mutations

```typescript
test('should create post successfully', async () => {
  const queryClient = createTestQueryClient();
  const user = userEvent.setup();

  // Mock the mutation endpoint
  global.fetch = jest.fn(() =>
    Promise.resolve({
      ok: true,
      json: () => Promise.resolve({ id: 1, title: 'Test Post' })
    })
  );

  render(
    <QueryClientProvider client={queryClient}>
      <CreatePostForm />
    </QueryClientProvider>
  );

  await user.type(screen.getByLabelText('Title'), 'Test Post');
  await user.click(screen.getByRole('button', { name: /create/i }));

  await waitFor(() => {
    expect(screen.getByText('Post created!')).toBeInTheDocument();
  });
});
```

### Testing with Mock Service Worker (My Preferred Approach)

I used to mock fetch directly, but Mock Service Worker (MSW) is way cleaner. It intercepts network requests at the network level, which feels more "real":

```typescript
// handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
  http.get('/api/users/:id', async ({ params }) => {
    return HttpResponse.json({ id: params.id, name: 'John' });
  }),
  http.post('/api/posts', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json({ id: 1, ...body });
  })
];

// test-setup.ts
import { setupServer } from 'msw/node';

export const server = setupServer(...handlers);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

Now tests don't need manual fetch mocks:

```typescript
test('fetches user', async () => {
  render(
    <QueryClientProvider client={queryClient}>
      <UserProfile userId="1" />
    </QueryClientProvider>
  );

  await waitFor(() => {
    expect(screen.getByText('John')).toBeInTheDocument();
  });
});
```

This feels more like an integration test and catches real issues. Plus if your API changes, your tests break immediately instead of staying green with mock data.

---

## When NOT to Use React Query (Real Talk)

I'm gonna be honest â€“ React Query isn't for everything. There are cases where you should NOT use it:

### 1\. Client-Only State

```typescript
// âŒ Don't use React Query for this
const { data: formInput } = useQuery({
  queryKey: ['formInput'],
  queryFn: () => ... // This doesn't make sense
});

// âœ… Just use useState
const [formInput, setFormInput] = useState('');
```

React Query is for server data. If the data never touches a server, useState is simpler.

### 2\. Real-Time Collaborative Data

```typescript
// âŒ React Query + polling won't be good enough
useQuery({
  queryKey: ['document'],
  refetchInterval: 1000  // 1 second polling is janky
});

// âœ… Use WebSockets instead
useEffect(() => {
  const ws = new WebSocket('wss://...');
  ws.onmessage = (msg) => {
    updateDocumentState(JSON.parse(msg.data));
  };
}, []);
```

When multiple users edit the same document, polling creates lag and bandwidth waste. Use WebSockets or something like Yjs.

### 3\. Highly Interconnected State

If your app is super complex with relationships like "when user changes, update their posts, and when posts change, update comments, and when comments change..." â€“ you might want Redux or Zustand instead. React Query is good for independent queries, not tightly coupled state.

### 4\. Small Apps

If your app fetches data in one place and that's it? React Query might be overkill. A single `useEffect` is fine. React Query shines when you have 10+ components fetching the same data in different ways.

**That said**, I've never regretted using React Query even on small projects. The setup is minimal and it scales if you grow. It's not harmful, just maybe unnecessary.

---

## Common Mistakes I Made (So You Don't Have To)

### Mistake 1: Objects in QueryKey

I kept doing this:

```typescript
// âŒ WRONG
const filters = { status: 'active', priority: 'high' };
useQuery({
  queryKey: [{ userId, filters }],  // Object in queryKey
  queryFn: fetchUsers
});
```

Objects are compared by reference, not value. Every render, new filters object = different object = React Query thinks it's a new query = constant refetching. So yeah, my app was making like 10 requests per second and I spent forever wondering why.

```typescript
// âœ… CORRECT
queryKey: ['users', userId, JSON.stringify(filters)]
```

Stringify it or just use primitives.

### Mistake 2: Forgetting to Return Data

```typescript
// âŒ WRONG
queryFn: async () => {
  const res = await fetch('/api/users');
  res.json();  // Oops, forgot return
}
// data is undefined, page is blank, you're confused
```

```typescript
// âœ… CORRECT
queryFn: async () => {
  const res = await fetch('/api/users');
  return res.json();
}
```

Yeah, I've done this. Function returns `undefined`, React Query gets nothing, page is blank. Fun times.

### Mistake 3: Not Checking HTTP Errors

```typescript
// âŒ WRONG
queryFn: async () => {
  const res = await fetch('/api/users');
  return res.json();  // Doesn't check if 404 or 500
}
```

```typescript
// âœ… CORRECT
queryFn: async () => {
  const res = await fetch('/api/users');
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}
```

Fetch doesn't reject on error status codes. You have to manually check `res.ok`.

### Mistake 4: Forgetting Dependencies in Dependent Queries

```typescript
// âŒ WRONG
const { data: user } = useQuery({ queryKey: ['currentUser'], queryFn: fetchCurrentUser });
const { data: posts } = useQuery({
  queryKey: ['posts'],  // Missing user.id
  queryFn: () => fetchPosts(user.id)
});
```

Posts query runs immediately before user loads, [user.id](http://user.id) is undefined, API fails or returns empty, then user loads but query doesn't refetch.

```typescript
// âœ… CORRECT
const { data: user } = useQuery({ queryKey: ['currentUser'], queryFn: fetchCurrentUser });
const { data: posts } = useQuery({
  queryKey: ['posts', user?.id],
  queryFn: () => fetchPosts(user.id),
  enabled: !!user?.id
});
```

Now it waits for user, then fetches posts. Simple fix, big difference.

### Mistake 5: Over-Invalidating

```typescript
// âŒ WRONG
onSuccess: () => {
  queryClient.invalidateQueries();  // Clears entire cache
}
```

Now everything refetches at once â€“ profile, notifications, all of it. Network spikes. App feels slow.

```typescript
// âœ… CORRECT
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: ['posts'] });
  // Only posts refetch
}
```

Be surgical. Only clear what actually changed.

### Mistake 6: Not Disabling Queries

```typescript
// âŒ WRONG
useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId)  // Fetches even if userId is null
});
```

```typescript
// âœ… CORRECT
useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId),
  enabled: !!userId  // Wait until userId exists
});
```

This is the one. `enabled: false` just means "not ready yet, chill."

---

## Interview Questions

### Junior Level

**Q1: What's the difference between** `staleTime` and `gcTime`?

A: `staleTime` determines when data becomes "stale" and needs refetching. `gcTime` determines how long to keep that stale data in memory. Think of it like food: stale time is when it's no longer fresh, GC time is when you throw it away.

**Q2: What does** `enabled: false` do?

A: Prevents a query from running. Useful when you don't have all the parameters yet (like waiting for user ID before fetching user details).

**Q3: How do you refetch data manually?**

A: Call the `refetch` function returned from `useQuery`:

```typescript
const { refetch } = useQuery({...});
<button onClick={() => refetch()}>Refresh</button>
```

**Q4: What's the difference between** `useMutation` and `useQuery`?

A: `useQuery` is for fetching/reading data. `useMutation` is for creating/updating/deleting data. Mutations have to be manually triggered, queries can refetch automatically.

**Q5: When would you use** `onMutate`?

A: For optimistic updates - showing the new data immediately before the server confirms.

---

### Mid Level

**Q6: How do you handle dependent queries?**

A:

```typescript
const { data: user } = useQuery({...});
const { data: posts } = useQuery({
  enabled: !!user?.id,
  queryKey: ['posts', user?.id],
  queryFn: () => fetchPosts(user.id)
});
```

**Q7: Explain request deduplication.**

A: If the same query is requested multiple times simultaneously, React Query only makes one network request and shares the result. This prevents redundant API calls.

**Q8: How would you implement pagination with React Query?**

A: Put the page number in the queryKey:

```typescript
queryKey: ['posts', page]
```

Each page is a separate cache entry. Switching pages automatically refetches that page's data.

**Q9: What's the purpose of** `useQueryClient()`?

A: Gets access to the QueryClient instance to manually control cache - invalidating, setting data, prefetching, etc.

**Q10: How do you handle API errors?**

A:

```typescript
const { error, isError } = useQuery({
  queryFn: async () => {
    const res = await fetch('/api/users');
    if (!res.ok) throw new Error(res.statusText);
    return res.json();
  }
});
```

---

### Senior Level

**Q11: Compare invalidation vs optimistic updates. When would you use each?**

A:

* **Invalidation**: Simple, safe, server is source of truth. Use for most cases.
    
* **Optimistic updates**: User sees change instantly, better UX. Use for critical features where network latency matters.
    

**Q12: How would you implement real-time updates with React Query?**

A:

```typescript
useEffect(() => {
  const ws = new WebSocket('wss://api.example.com');
  ws.onmessage = (event) => {
    // Update cache when server pushes data
    queryClient.setQueryData(['posts'], event.data);
  };
  return () => ws.close();
}, [queryClient]);
```

**Q13: Explain race conditions in dependent queries and how to prevent them.**

A: If query A depends on query B's data, but query B fetches slowly while query C triggers, query C might execute with stale data. Prevention: use `enabled: !!`[`queryB.data`](http://queryB.data) to ensure B completes first.

**Q14: How do you optimize for performance in React Query?**

A:

* Set appropriate `staleTime` (less refetching)
    
* Use `refetchInterval` wisely
    
* Implement `keepPreviousData` for smooth pagination
    
* Use `select` to memoize transformations
    

**Q15: What's** `select` and when would you use it?

A: Transforms fetched data without creating new objects:

```typescript
useQuery({
  queryKey: ['user'],
  queryFn: fetchUser,
  select: (data) => data.name  // Only keep name, not full user
});
```

---

### Real Interview Scenario

**"Walk me through building a paginated list of users with search and filters."**

```typescript
function UsersList() {
  const [page, setPage] = useState(1);
  const [search, setSearch] = useState('');
  const [filters, setFilters] = useState({});

  const { data, isLoading, error } = useQuery({
    queryKey: ['users', page, search, filters],
    queryFn: async () => {
      const params = new URLSearchParams({
        page: String(page),
        search,
        ...filters
      });
      const res = await fetch(`/api/users?${params}`);
      if (!res.ok) throw new Error('Failed to fetch');
      return res.json();
    },
    staleTime: 1000 * 60 * 5  // Cache for 5 minutes
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <input
        value={search}
        onChange={(e) => {
          setSearch(e.target.value);
          setPage(1);  // Reset to page 1
        }}
        placeholder="Search users..."
      />

      <div>
        {data.users.map(user => (
          <div key={user.id}>{user.name}</div>
        ))}
      </div>

      <div>
        <button
          onClick={() => setPage(p => p - 1)}
          disabled={page === 1}
        >
          Previous
        </button>
        <span>Page {page}</span>
        <button
          onClick={() => setPage(p => p + 1)}
          disabled={!data.hasMore}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

---

## Performance Tips

### Tip 1: Use `keepPreviousData`

```typescript
useQuery({
  queryKey: ['posts', page],
  queryFn: fetchPosts,
  keepPreviousData: true  // Show old page while new page loads
});
```

### Tip 2: Implement `select`

```typescript
// Without select - whole object re-renders if anything changes
const { data } = useQuery({ queryKey: ['user'], queryFn: fetchUser });

// With select - only re-render if name changes
const { data: userName } = useQuery({
  queryKey: ['user'],
  queryFn: fetchUser,
  select: (data) => data.name
});
```

### Tip 3: Prefetch on Hover

```typescript
function UserLink({ userId }) {
  const queryClient = useQueryClient();

  return (
    <a
      onMouseEnter={() => {
        queryClient.prefetchQuery({
          queryKey: ['user', userId],
          queryFn: () => fetchUser(userId)
        });
      }}
    >
      View user
    </a>
  );
}
```

User hovers, data silently loads. Click = instant!

### Tip 4: Lazy Loading

```typescript
// Don't fetch unless you have the ID
const { data: user } = useQuery({
  queryKey: ['user', userId],
  queryFn: fetchUser,
  enabled: !!userId  // Only fetch if userId exists
});
```

---

## Quick Reference

### Query States

```typescript
const {
  data,           // The data
  isLoading,      // First load (no data yet)
  isPending,      // Any loading (includes background)
  isError,        // Has error
  error,          // The error object
  status,         // 'pending' | 'error' | 'success'
  isFetching,     // Any fetch happening
  isRefetching,   // Refetch (not initial load)
  refetch         // Manual refetch function
} = useQuery({...});
```

### Mutation States

```typescript
const {
  data,           // Return value from server
  mutate,         // Function to trigger mutation
  mutateAsync,    // Same but returns promise
  isPending,      // Is mutating
  isError,        // Has error
  error,          // The error
  status,         // 'idle' | 'pending' | 'error' | 'success'
  reset           // Reset mutation state
} = useMutation({...});
```

---

## Real-World Project Structure

```plaintext
src/
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useQueries.ts       // Custom hooks wrapping React Query
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ api.ts              // API client (fetch/axios)
â”‚   â””â”€â”€ queryClient.ts      // QueryClient configuration
â”œâ”€â”€ queries/
â”‚   â”œâ”€â”€ userQueries.ts      // User-related queries
â”‚   â”œâ”€â”€ postQueries.ts      // Post-related queries
â”‚   â””â”€â”€ mutations.ts        // Mutations
â”œâ”€â”€ components/
â”‚   â””â”€â”€ UserProfile.tsx
â””â”€â”€ App.tsx
```

### queryClient.ts

```typescript
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,
      gcTime: 1000 * 60 * 10,
      retry: 1,
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000)
    }
  }
});
```

### userQueries.ts

```typescript
import { useQuery } from '@tanstack/react-query';
import { fetchUser, fetchUsers } from '@/services/api';

export const useUser = (id: string) =>
  useQuery({
    queryKey: ['user', id],
    queryFn: () => fetchUser(id)
  });

export const useUsers = () =>
  useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers
  });
```

---

## Wrapping Up

I said this earlier but I'll say it again: React Query transformed how I think about data in React applications.

When I first tried it, I saw it as "yet another library to learn." Now I see it as "the thing that made React data fetching finally make sense."

The moment it clicked for me was when I understood that caching isn't magic â€“ it's just "don't refetch the same data twice in 5 minutes." Once you get that, everything else follows. Staleness, invalidation, deduplication â€“ it all makes sense.

Here's my honest take: If you're managing data fetching with `useState` and `useEffect`, you're probably making things harder than they need to be. It'll work, sure. But you'll spend time debugging race conditions and cache inconsistencies that React Query just... prevents.

My biggest regret is not learning this sooner. I spent months over-engineering solutions for problems React Query solves out of the box.

### What Actually Happens When You Use This

Starting out:

1. You'll spend 30 minutes setting it up (5 minutes of actual code, 25 minutes reading docs)
    
2. You'll convert one useEffect to useQuery
    
3. You'll be like "okay... it works the same"
    
4. Then you'll navigate away and back
    
5. No refetch. Instant data.
    
6. You'll think "wait, that's it? That was the problem?"
    

Scaling up:

1. Your app grows, more components fetch data
    
2. Components stop duplicating, share cache automatically
    
3. Your mutations work better because invalidation is explicit
    
4. You add a little refetch on focus, data stays fresh
    
5. Your app feels snappier and you didn't add much code
    

Six months later:

1. You can't imagine building React apps without it
    
2. You evangelize to other developers
    
3. You help junior devs avoid the mistakes you made
    

### Your Actual Next Steps

1. **Clone a simple project** (todo app, weather app, anything)
    
2. **Remove any fetch logic**
    
3. **Set up React Query** (literally 3 minutes with the code above)
    
4. **Convert ONE feature** to use useQuery
    
5. **Test it**, see it work
    
6. Do the next one
    
7. Stop using `useState` for API data (seriously, just stop)
    
8. When you need caching or refetching, you'll already know how
    

Don't try to understand everything at once. Start simple. Use basic `useQuery`. Then add mutations. Then play with invalidation. Then optimistic updates. The library scales with you.

### The Community

React Query (TanStack Query now) has an active community. The creator Tanner Linsley is incredibly responsive. GitHub issues get answered. There's a Discord if you get stuck. It's not some abandonware.

I've been using it in production for multiple companies now. Never regretted it once. Every new feature request, React Query just... has it. Or there's a clear pattern for implementing it.

---

## Resources

* [React Query Official Docs](https://tanstack.com/query/latest) - Seriously read this
    
* [React Query GitHub](https://github.com/tanstack/query) - Source code, issues, discussions
    
* [Tanner Linsley YouTube](https://www.youtube.com/@tanner_linsley) - Creator's channel with deep dives
    
* [React Query Testing](https://tanstack.com/query/latest/docs/react/testing) - How to test correctly
    

---

*Happy CodingðŸ¥°*